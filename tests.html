<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QR Code Generator - Test Suite</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #f5f5f5;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }

        .summary {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .summary-item {
            background: white;
            padding: 20px 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
        }

        .summary-value {
            font-size: 36px;
            font-weight: 700;
        }

        .summary-label {
            font-size: 14px;
            color: #666;
            text-transform: uppercase;
        }

        .passed .summary-value { color: #28a745; }
        .failed .summary-value { color: #dc3545; }
        .total .summary-value { color: #333; }

        .test-section {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            overflow: hidden;
        }

        .section-header {
            background: #667eea;
            color: white;
            padding: 15px 20px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .section-header .badge {
            background: rgba(255,255,255,0.2);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
        }

        .test-list {
            padding: 0;
        }

        .test-item {
            padding: 12px 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .test-item:last-child {
            border-bottom: none;
        }

        .test-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .test-icon.pass {
            background: #d4edda;
            color: #28a745;
        }

        .test-icon.fail {
            background: #f8d7da;
            color: #dc3545;
        }

        .test-name {
            flex: 1;
            font-size: 14px;
        }

        .test-details {
            font-size: 12px;
            color: #666;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .test-time {
            font-size: 12px;
            color: #999;
            min-width: 60px;
            text-align: right;
        }

        .visual-tests {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            padding: 20px;
        }

        .visual-test {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .visual-test h4 {
            margin-bottom: 10px;
            font-size: 14px;
        }

        .visual-test canvas {
            border: 2px solid #333;
            border-radius: 4px;
            background: white;
        }

        .visual-test .meta {
            margin-top: 10px;
            font-size: 12px;
            color: #666;
        }

        .manual-section {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 20px;
            margin-top: 30px;
        }

        .manual-section h3 {
            color: #856404;
            margin-bottom: 15px;
        }

        .manual-section ul {
            margin-left: 20px;
            color: #856404;
        }

        .manual-section li {
            margin-bottom: 8px;
        }

        .controls {
            text-align: center;
            margin-bottom: 30px;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: #667eea;
            color: white;
            margin: 0 10px;
        }

        button:hover {
            background: #5a6fd6;
        }

        .status-running {
            color: #856404;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>QR Code Generator - Test Suite</h1>
        <p class="subtitle">ISO/IEC 18004:2024 Compliance Tests</p>

        <div class="controls">
            <button id="runTests">Run All Tests</button>
        </div>

        <div class="summary" id="summary">
            <div class="summary-item total">
                <div class="summary-value" id="totalCount">0</div>
                <div class="summary-label">Total Tests</div>
            </div>
            <div class="summary-item passed">
                <div class="summary-value" id="passedCount">0</div>
                <div class="summary-label">Passed</div>
            </div>
            <div class="summary-item failed">
                <div class="summary-value" id="failedCount">0</div>
                <div class="summary-label">Failed</div>
            </div>
        </div>

        <div id="testResults"></div>

        <div class="test-section" id="visualTests">
            <div class="section-header">
                <span>Visual Tests - Generated QR Codes</span>
                <span class="badge" id="visualBadge">0 codes</span>
            </div>
            <div class="visual-tests" id="visualTestContainer"></div>
        </div>

        <div class="manual-section">
            <h3>Manual Validation Instructions</h3>
            <ul>
                <li>Use a smartphone QR scanner app to scan each generated QR code above</li>
                <li>Verify that the decoded URL matches the expected value shown below each code</li>
                <li>Test scanning at different angles and distances to verify robustness</li>
                <li>Verify the QR code maintains readability after downloading as PNG</li>
                <li>Test with different error correction levels to observe the visual difference</li>
            </ul>
        </div>
    </div>

    <script>
    /**
     * QR Code Generator - Embedded for Testing
     * (Complete copy from index.html for standalone testing)
     */
    const QRCode = (function() {
        'use strict';

        const ECC_LEVELS = { L: 0, M: 1, Q: 2, H: 3 };
        const ECC_INDICATORS = { L: 0b01, M: 0b00, Q: 0b11, H: 0b10 };

        const MODE = {
            NUMERIC: 0b0001,
            ALPHANUMERIC: 0b0010,
            BYTE: 0b0100,
            KANJI: 0b1000,
            TERMINATOR: 0b0000
        };

        const ALPHANUMERIC_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';

        const CHAR_COUNT_BITS = {
            NUMERIC: [10, 12, 14],
            ALPHANUMERIC: [9, 11, 13],
            BYTE: [8, 16, 16],
            KANJI: [8, 10, 12]
        };

        const BYTE_CAPACITY = [
            null,
            [17, 14, 11, 7],
            [32, 26, 20, 14],
            [53, 42, 32, 24],
            [78, 62, 46, 34],
            [106, 84, 60, 44],
            [134, 106, 74, 58],
            [154, 122, 86, 64],
            [192, 152, 108, 84],
            [230, 180, 130, 98],
            [271, 213, 151, 119],
            [321, 251, 177, 137],
            [367, 287, 203, 155],
            [425, 331, 241, 177],
            [458, 362, 258, 194],
            [520, 412, 292, 220],
            [586, 450, 322, 250],
            [644, 504, 364, 280],
            [718, 560, 394, 310],
            [792, 624, 442, 338],
            [858, 666, 482, 382],
            [929, 711, 509, 403],
            [1003, 779, 565, 439],
            [1091, 857, 611, 461],
            [1171, 911, 661, 511],
            [1273, 997, 715, 535],
            [1367, 1059, 751, 593],
            [1465, 1125, 805, 625],
            [1528, 1190, 868, 658],
            [1628, 1264, 908, 698],
            [1732, 1370, 982, 742],
            [1840, 1452, 1030, 790],
            [1952, 1538, 1112, 842],
            [2068, 1628, 1168, 898],
            [2188, 1722, 1228, 958],
            [2303, 1809, 1283, 983],
            [2431, 1911, 1351, 1051],
            [2563, 1989, 1423, 1093],
            [2699, 2099, 1499, 1139],
            [2809, 2213, 1579, 1219],
            [2953, 2331, 1663, 1273]
        ];

        const ECC_TABLE = {
            1: {
                L: { total: 26, eccPerBlock: 7, blocks: [[1, 19]] },
                M: { total: 26, eccPerBlock: 10, blocks: [[1, 16]] },
                Q: { total: 26, eccPerBlock: 13, blocks: [[1, 13]] },
                H: { total: 26, eccPerBlock: 17, blocks: [[1, 9]] }
            },
            2: {
                L: { total: 44, eccPerBlock: 10, blocks: [[1, 34]] },
                M: { total: 44, eccPerBlock: 16, blocks: [[1, 28]] },
                Q: { total: 44, eccPerBlock: 22, blocks: [[1, 22]] },
                H: { total: 44, eccPerBlock: 28, blocks: [[1, 16]] }
            },
            3: {
                L: { total: 70, eccPerBlock: 15, blocks: [[1, 55]] },
                M: { total: 70, eccPerBlock: 26, blocks: [[1, 44]] },
                Q: { total: 70, eccPerBlock: 18, blocks: [[2, 17]] },
                H: { total: 70, eccPerBlock: 22, blocks: [[2, 13]] }
            },
            4: {
                L: { total: 100, eccPerBlock: 20, blocks: [[1, 80]] },
                M: { total: 100, eccPerBlock: 18, blocks: [[2, 32]] },
                Q: { total: 100, eccPerBlock: 26, blocks: [[2, 24]] },
                H: { total: 100, eccPerBlock: 16, blocks: [[4, 9]] }
            },
            5: {
                L: { total: 134, eccPerBlock: 26, blocks: [[1, 108]] },
                M: { total: 134, eccPerBlock: 24, blocks: [[2, 43]] },
                Q: { total: 134, eccPerBlock: 18, blocks: [[2, 15], [2, 16]] },
                H: { total: 134, eccPerBlock: 22, blocks: [[2, 11], [2, 12]] }
            },
            6: {
                L: { total: 172, eccPerBlock: 18, blocks: [[2, 68]] },
                M: { total: 172, eccPerBlock: 16, blocks: [[4, 27]] },
                Q: { total: 172, eccPerBlock: 24, blocks: [[4, 19]] },
                H: { total: 172, eccPerBlock: 28, blocks: [[4, 15]] }
            },
            7: {
                L: { total: 196, eccPerBlock: 20, blocks: [[2, 78]] },
                M: { total: 196, eccPerBlock: 18, blocks: [[4, 31]] },
                Q: { total: 196, eccPerBlock: 18, blocks: [[2, 14], [4, 15]] },
                H: { total: 196, eccPerBlock: 26, blocks: [[4, 13], [1, 14]] }
            },
            8: {
                L: { total: 242, eccPerBlock: 24, blocks: [[2, 97]] },
                M: { total: 242, eccPerBlock: 22, blocks: [[2, 38], [2, 39]] },
                Q: { total: 242, eccPerBlock: 22, blocks: [[4, 18], [2, 19]] },
                H: { total: 242, eccPerBlock: 26, blocks: [[4, 14], [2, 15]] }
            },
            9: {
                L: { total: 292, eccPerBlock: 30, blocks: [[2, 116]] },
                M: { total: 292, eccPerBlock: 22, blocks: [[3, 36], [2, 37]] },
                Q: { total: 292, eccPerBlock: 20, blocks: [[4, 16], [4, 17]] },
                H: { total: 292, eccPerBlock: 24, blocks: [[4, 12], [4, 13]] }
            },
            10: {
                L: { total: 346, eccPerBlock: 18, blocks: [[2, 68], [2, 69]] },
                M: { total: 346, eccPerBlock: 26, blocks: [[4, 43], [1, 44]] },
                Q: { total: 346, eccPerBlock: 24, blocks: [[6, 19], [2, 20]] },
                H: { total: 346, eccPerBlock: 28, blocks: [[6, 15], [2, 16]] }
            },
            11: { L: { total: 404, eccPerBlock: 20, blocks: [[4, 81]] }, M: { total: 404, eccPerBlock: 30, blocks: [[1, 50], [4, 51]] }, Q: { total: 404, eccPerBlock: 28, blocks: [[4, 22], [4, 23]] }, H: { total: 404, eccPerBlock: 24, blocks: [[3, 12], [8, 13]] } },
            12: { L: { total: 466, eccPerBlock: 24, blocks: [[2, 92], [2, 93]] }, M: { total: 466, eccPerBlock: 22, blocks: [[6, 36], [2, 37]] }, Q: { total: 466, eccPerBlock: 26, blocks: [[4, 20], [6, 21]] }, H: { total: 466, eccPerBlock: 28, blocks: [[7, 14], [4, 15]] } },
            13: { L: { total: 532, eccPerBlock: 26, blocks: [[4, 107]] }, M: { total: 532, eccPerBlock: 22, blocks: [[8, 37], [1, 38]] }, Q: { total: 532, eccPerBlock: 24, blocks: [[8, 20], [4, 21]] }, H: { total: 532, eccPerBlock: 22, blocks: [[12, 11], [4, 12]] } },
            14: { L: { total: 581, eccPerBlock: 30, blocks: [[3, 115], [1, 116]] }, M: { total: 581, eccPerBlock: 24, blocks: [[4, 40], [5, 41]] }, Q: { total: 581, eccPerBlock: 20, blocks: [[11, 16], [5, 17]] }, H: { total: 581, eccPerBlock: 24, blocks: [[11, 12], [5, 13]] } },
            15: { L: { total: 655, eccPerBlock: 22, blocks: [[5, 87], [1, 88]] }, M: { total: 655, eccPerBlock: 24, blocks: [[5, 41], [5, 42]] }, Q: { total: 655, eccPerBlock: 30, blocks: [[5, 24], [7, 25]] }, H: { total: 655, eccPerBlock: 24, blocks: [[11, 12], [7, 13]] } },
            16: { L: { total: 733, eccPerBlock: 24, blocks: [[5, 98], [1, 99]] }, M: { total: 733, eccPerBlock: 28, blocks: [[7, 45], [3, 46]] }, Q: { total: 733, eccPerBlock: 24, blocks: [[15, 19], [2, 20]] }, H: { total: 733, eccPerBlock: 30, blocks: [[3, 15], [13, 16]] } },
            17: { L: { total: 815, eccPerBlock: 28, blocks: [[1, 107], [5, 108]] }, M: { total: 815, eccPerBlock: 28, blocks: [[10, 46], [1, 47]] }, Q: { total: 815, eccPerBlock: 28, blocks: [[1, 22], [15, 23]] }, H: { total: 815, eccPerBlock: 28, blocks: [[2, 14], [17, 15]] } },
            18: { L: { total: 901, eccPerBlock: 30, blocks: [[5, 120], [1, 121]] }, M: { total: 901, eccPerBlock: 26, blocks: [[9, 43], [4, 44]] }, Q: { total: 901, eccPerBlock: 28, blocks: [[17, 22], [1, 23]] }, H: { total: 901, eccPerBlock: 28, blocks: [[2, 14], [19, 15]] } },
            19: { L: { total: 991, eccPerBlock: 28, blocks: [[3, 113], [4, 114]] }, M: { total: 991, eccPerBlock: 26, blocks: [[3, 44], [11, 45]] }, Q: { total: 991, eccPerBlock: 26, blocks: [[17, 21], [4, 22]] }, H: { total: 991, eccPerBlock: 26, blocks: [[9, 13], [16, 14]] } },
            20: { L: { total: 1085, eccPerBlock: 28, blocks: [[3, 107], [5, 108]] }, M: { total: 1085, eccPerBlock: 26, blocks: [[3, 41], [13, 42]] }, Q: { total: 1085, eccPerBlock: 30, blocks: [[15, 24], [5, 25]] }, H: { total: 1085, eccPerBlock: 28, blocks: [[15, 15], [10, 16]] } },
            21: { L: { total: 1156, eccPerBlock: 28, blocks: [[4, 116], [4, 117]] }, M: { total: 1156, eccPerBlock: 26, blocks: [[17, 42]] }, Q: { total: 1156, eccPerBlock: 28, blocks: [[17, 22], [6, 23]] }, H: { total: 1156, eccPerBlock: 30, blocks: [[19, 16], [6, 17]] } },
            22: { L: { total: 1258, eccPerBlock: 28, blocks: [[2, 111], [7, 112]] }, M: { total: 1258, eccPerBlock: 28, blocks: [[17, 46]] }, Q: { total: 1258, eccPerBlock: 30, blocks: [[7, 24], [16, 25]] }, H: { total: 1258, eccPerBlock: 24, blocks: [[34, 13]] } },
            23: { L: { total: 1364, eccPerBlock: 30, blocks: [[4, 121], [5, 122]] }, M: { total: 1364, eccPerBlock: 28, blocks: [[4, 47], [14, 48]] }, Q: { total: 1364, eccPerBlock: 30, blocks: [[11, 24], [14, 25]] }, H: { total: 1364, eccPerBlock: 30, blocks: [[16, 15], [14, 16]] } },
            24: { L: { total: 1474, eccPerBlock: 30, blocks: [[6, 117], [4, 118]] }, M: { total: 1474, eccPerBlock: 28, blocks: [[6, 45], [14, 46]] }, Q: { total: 1474, eccPerBlock: 30, blocks: [[11, 24], [16, 25]] }, H: { total: 1474, eccPerBlock: 30, blocks: [[30, 16], [2, 17]] } },
            25: { L: { total: 1588, eccPerBlock: 26, blocks: [[8, 106], [4, 107]] }, M: { total: 1588, eccPerBlock: 28, blocks: [[8, 47], [13, 48]] }, Q: { total: 1588, eccPerBlock: 30, blocks: [[7, 24], [22, 25]] }, H: { total: 1588, eccPerBlock: 30, blocks: [[22, 15], [13, 16]] } },
            26: { L: { total: 1706, eccPerBlock: 28, blocks: [[10, 114], [2, 115]] }, M: { total: 1706, eccPerBlock: 28, blocks: [[19, 46], [4, 47]] }, Q: { total: 1706, eccPerBlock: 28, blocks: [[28, 22], [6, 23]] }, H: { total: 1706, eccPerBlock: 30, blocks: [[33, 16], [4, 17]] } },
            27: { L: { total: 1828, eccPerBlock: 30, blocks: [[8, 122], [4, 123]] }, M: { total: 1828, eccPerBlock: 28, blocks: [[22, 45], [3, 46]] }, Q: { total: 1828, eccPerBlock: 30, blocks: [[8, 23], [26, 24]] }, H: { total: 1828, eccPerBlock: 30, blocks: [[12, 15], [28, 16]] } },
            28: { L: { total: 1921, eccPerBlock: 30, blocks: [[3, 117], [10, 118]] }, M: { total: 1921, eccPerBlock: 28, blocks: [[3, 45], [23, 46]] }, Q: { total: 1921, eccPerBlock: 30, blocks: [[4, 24], [31, 25]] }, H: { total: 1921, eccPerBlock: 30, blocks: [[11, 15], [31, 16]] } },
            29: { L: { total: 2051, eccPerBlock: 30, blocks: [[7, 116], [7, 117]] }, M: { total: 2051, eccPerBlock: 28, blocks: [[21, 45], [7, 46]] }, Q: { total: 2051, eccPerBlock: 30, blocks: [[1, 23], [37, 24]] }, H: { total: 2051, eccPerBlock: 30, blocks: [[19, 15], [26, 16]] } },
            30: { L: { total: 2185, eccPerBlock: 30, blocks: [[5, 115], [10, 116]] }, M: { total: 2185, eccPerBlock: 28, blocks: [[19, 47], [10, 48]] }, Q: { total: 2185, eccPerBlock: 30, blocks: [[15, 24], [25, 25]] }, H: { total: 2185, eccPerBlock: 30, blocks: [[23, 15], [25, 16]] } },
            31: { L: { total: 2323, eccPerBlock: 30, blocks: [[13, 115], [3, 116]] }, M: { total: 2323, eccPerBlock: 28, blocks: [[2, 46], [29, 47]] }, Q: { total: 2323, eccPerBlock: 30, blocks: [[42, 24], [1, 25]] }, H: { total: 2323, eccPerBlock: 30, blocks: [[23, 15], [28, 16]] } },
            32: { L: { total: 2465, eccPerBlock: 30, blocks: [[17, 115]] }, M: { total: 2465, eccPerBlock: 28, blocks: [[10, 46], [23, 47]] }, Q: { total: 2465, eccPerBlock: 30, blocks: [[10, 24], [35, 25]] }, H: { total: 2465, eccPerBlock: 30, blocks: [[19, 15], [35, 16]] } },
            33: { L: { total: 2611, eccPerBlock: 30, blocks: [[17, 115], [1, 116]] }, M: { total: 2611, eccPerBlock: 28, blocks: [[14, 46], [21, 47]] }, Q: { total: 2611, eccPerBlock: 30, blocks: [[29, 24], [19, 25]] }, H: { total: 2611, eccPerBlock: 30, blocks: [[11, 15], [46, 16]] } },
            34: { L: { total: 2761, eccPerBlock: 30, blocks: [[13, 115], [6, 116]] }, M: { total: 2761, eccPerBlock: 28, blocks: [[14, 46], [23, 47]] }, Q: { total: 2761, eccPerBlock: 30, blocks: [[44, 24], [7, 25]] }, H: { total: 2761, eccPerBlock: 30, blocks: [[59, 16], [1, 17]] } },
            35: { L: { total: 2876, eccPerBlock: 30, blocks: [[12, 121], [7, 122]] }, M: { total: 2876, eccPerBlock: 28, blocks: [[12, 47], [26, 48]] }, Q: { total: 2876, eccPerBlock: 30, blocks: [[39, 24], [14, 25]] }, H: { total: 2876, eccPerBlock: 30, blocks: [[22, 15], [41, 16]] } },
            36: { L: { total: 3034, eccPerBlock: 30, blocks: [[6, 121], [14, 122]] }, M: { total: 3034, eccPerBlock: 28, blocks: [[6, 47], [34, 48]] }, Q: { total: 3034, eccPerBlock: 30, blocks: [[46, 24], [10, 25]] }, H: { total: 3034, eccPerBlock: 30, blocks: [[2, 15], [64, 16]] } },
            37: { L: { total: 3196, eccPerBlock: 30, blocks: [[17, 122], [4, 123]] }, M: { total: 3196, eccPerBlock: 28, blocks: [[29, 46], [14, 47]] }, Q: { total: 3196, eccPerBlock: 30, blocks: [[49, 24], [10, 25]] }, H: { total: 3196, eccPerBlock: 30, blocks: [[24, 15], [46, 16]] } },
            38: { L: { total: 3362, eccPerBlock: 30, blocks: [[4, 122], [18, 123]] }, M: { total: 3362, eccPerBlock: 28, blocks: [[13, 46], [32, 47]] }, Q: { total: 3362, eccPerBlock: 30, blocks: [[48, 24], [14, 25]] }, H: { total: 3362, eccPerBlock: 30, blocks: [[42, 15], [32, 16]] } },
            39: { L: { total: 3532, eccPerBlock: 30, blocks: [[20, 117], [4, 118]] }, M: { total: 3532, eccPerBlock: 28, blocks: [[40, 47], [7, 48]] }, Q: { total: 3532, eccPerBlock: 30, blocks: [[43, 24], [22, 25]] }, H: { total: 3532, eccPerBlock: 30, blocks: [[10, 15], [67, 16]] } },
            40: { L: { total: 3706, eccPerBlock: 30, blocks: [[19, 118], [6, 119]] }, M: { total: 3706, eccPerBlock: 28, blocks: [[18, 47], [31, 48]] }, Q: { total: 3706, eccPerBlock: 30, blocks: [[34, 24], [34, 25]] }, H: { total: 3706, eccPerBlock: 30, blocks: [[20, 15], [61, 16]] } }
        };

        const ALIGNMENT_PATTERNS = [
            null, [], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34],
            [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50],
            [6, 30, 54], [6, 32, 58], [6, 34, 62],
            [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74],
            [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86],
            [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98],
            [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110],
            [6, 30, 58, 86, 114], [6, 34, 62, 90, 118],
            [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126],
            [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134],
            [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142],
            [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150],
            [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158],
            [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166],
            [6, 30, 58, 86, 114, 142, 170]
        ];

        const VERSION_INFO = [
            null, null, null, null, null, null, null,
            0x07C94, 0x085BC, 0x09A99, 0x0A4D3, 0x0BBF6, 0x0C762, 0x0D847, 0x0E60D, 0x0F928,
            0x10B78, 0x1145D, 0x12A17, 0x13532, 0x149A6, 0x15683, 0x168C9, 0x177EC,
            0x18EC4, 0x191E1, 0x1AFAB, 0x1B08E, 0x1CC1A, 0x1D33F, 0x1ED75, 0x1F250,
            0x209D5, 0x216F0, 0x228BA, 0x2379F, 0x24B0B, 0x2542E, 0x26A64, 0x27541, 0x28C69
        ];

        const FORMAT_INFO = [
            0x5412, 0x5125, 0x5E7C, 0x5B4B, 0x45F9, 0x40CE, 0x4F97, 0x4AA0,
            0x77C4, 0x72F3, 0x7DAA, 0x789D, 0x662F, 0x6318, 0x6C41, 0x6976,
            0x1689, 0x13BE, 0x1CE7, 0x19D0, 0x0762, 0x0255, 0x0D0C, 0x083B,
            0x355F, 0x3068, 0x3F31, 0x3A06, 0x24B4, 0x2183, 0x2EDA, 0x2BED
        ];

        const REMAINDER_BITS = [
            0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3,
            4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0
        ];

        const GF_EXP = new Uint8Array(512);
        const GF_LOG = new Uint8Array(256);

        (function initGaloisField() {
            let x = 1;
            for (let i = 0; i < 255; i++) {
                GF_EXP[i] = x;
                GF_LOG[x] = i;
                x <<= 1;
                if (x & 0x100) x ^= 0x11D;
            }
            for (let i = 255; i < 512; i++) {
                GF_EXP[i] = GF_EXP[i - 255];
            }
        })();

        function gfMultiply(a, b) {
            if (a === 0 || b === 0) return 0;
            return GF_EXP[GF_LOG[a] + GF_LOG[b]];
        }

        function generateRSPolynomial(numEcc) {
            let poly = new Uint8Array(numEcc + 1);
            poly[0] = 1;
            for (let i = 0; i < numEcc; i++) {
                for (let j = numEcc; j > 0; j--) {
                    poly[j] = poly[j - 1] ^ gfMultiply(poly[j], GF_EXP[i]);
                }
                poly[0] = gfMultiply(poly[0], GF_EXP[i]);
            }
            return poly;
        }

        function calculateECC(data, numEcc) {
            const generator = generateRSPolynomial(numEcc);
            const ecc = new Uint8Array(numEcc);
            for (let i = 0; i < data.length; i++) {
                const coef = data[i] ^ ecc[0];
                for (let j = 0; j < numEcc - 1; j++) {
                    ecc[j] = ecc[j + 1];
                }
                ecc[numEcc - 1] = 0;
                // ecc[j] represents coefficient of x^(numEcc-1-j)
                // generator[k] represents coefficient of x^k
                // So ecc[j] should be XORed with generator[numEcc-1-j]
                for (let j = 0; j < numEcc; j++) {
                    ecc[j] ^= gfMultiply(generator[numEcc - 1 - j], coef);
                }
            }
            return ecc;
        }

        function isNumeric(char) {
            const code = char.charCodeAt(0);
            return code >= 0x30 && code <= 0x39;
        }

        function isAlphanumeric(char) {
            // Per ISO/IEC 18004, only uppercase A-Z (not lowercase) are alphanumeric
            return ALPHANUMERIC_CHARS.indexOf(char) !== -1;
        }

        function detectMode(data) {
            let allNumeric = true;
            let allAlphanumeric = true;
            for (let i = 0; i < data.length; i++) {
                const char = data[i];
                if (!isNumeric(char)) allNumeric = false;
                if (!isAlphanumeric(char)) allAlphanumeric = false;
            }
            if (allNumeric) return 'NUMERIC';
            if (allAlphanumeric) return 'ALPHANUMERIC';
            return 'BYTE';
        }

        function getCharCountBits(version, mode) {
            let index;
            if (version <= 9) index = 0;
            else if (version <= 26) index = 1;
            else index = 2;
            return CHAR_COUNT_BITS[mode][index];
        }

        function encodeNumeric(data) {
            const bits = [];
            let i = 0;
            while (i < data.length) {
                if (i + 3 <= data.length) {
                    const num = parseInt(data.substr(i, 3), 10);
                    for (let j = 9; j >= 0; j--) bits.push((num >> j) & 1);
                    i += 3;
                } else if (i + 2 <= data.length) {
                    const num = parseInt(data.substr(i, 2), 10);
                    for (let j = 6; j >= 0; j--) bits.push((num >> j) & 1);
                    i += 2;
                } else {
                    const num = parseInt(data[i], 10);
                    for (let j = 3; j >= 0; j--) bits.push((num >> j) & 1);
                    i += 1;
                }
            }
            return bits;
        }

        function encodeAlphanumeric(data) {
            const bits = [];
            const upperData = data.toUpperCase();
            let i = 0;
            while (i < upperData.length) {
                if (i + 2 <= upperData.length) {
                    const val1 = ALPHANUMERIC_CHARS.indexOf(upperData[i]);
                    const val2 = ALPHANUMERIC_CHARS.indexOf(upperData[i + 1]);
                    const num = val1 * 45 + val2;
                    for (let j = 10; j >= 0; j--) bits.push((num >> j) & 1);
                    i += 2;
                } else {
                    const val = ALPHANUMERIC_CHARS.indexOf(upperData[i]);
                    for (let j = 5; j >= 0; j--) bits.push((val >> j) & 1);
                    i += 1;
                }
            }
            return bits;
        }

        function encodeByte(data) {
            const bits = [];
            const encoder = new TextEncoder();
            const bytes = encoder.encode(data);
            for (let i = 0; i < bytes.length; i++) {
                for (let j = 7; j >= 0; j--) bits.push((bytes[i] >> j) & 1);
            }
            return bits;
        }

        function selectVersion(dataLength, eccLevel, mode) {
            const eccIndex = ECC_LEVELS[eccLevel];
            for (let version = 1; version <= 40; version++) {
                const eccInfo = ECC_TABLE[version][eccLevel];
                let totalDataCodewords = 0;
                for (const [count, dataWords] of eccInfo.blocks) {
                    totalDataCodewords += count * dataWords;
                }
                const totalDataBits = totalDataCodewords * 8;
                let requiredBits = 4 + getCharCountBits(version, mode);
                if (mode === 'NUMERIC') {
                    const groups = Math.floor(dataLength / 3);
                    const remainder = dataLength % 3;
                    requiredBits += groups * 10;
                    if (remainder === 2) requiredBits += 7;
                    else if (remainder === 1) requiredBits += 4;
                } else if (mode === 'ALPHANUMERIC') {
                    const pairs = Math.floor(dataLength / 2);
                    const remainder = dataLength % 2;
                    requiredBits += pairs * 11 + remainder * 6;
                } else {
                    requiredBits += dataLength * 8;
                }
                if (requiredBits <= totalDataBits) return version;
            }
            return -1;
        }

        function createDataBitstream(data, version, eccLevel, mode) {
            const bits = [];
            const modeIndicator = MODE[mode];
            for (let i = 3; i >= 0; i--) bits.push((modeIndicator >> i) & 1);
            const countBits = getCharCountBits(version, mode);
            let charCount;
            if (mode === 'BYTE') {
                const encoder = new TextEncoder();
                charCount = encoder.encode(data).length;
            } else {
                charCount = data.length;
            }
            for (let i = countBits - 1; i >= 0; i--) bits.push((charCount >> i) & 1);
            let dataBits;
            if (mode === 'NUMERIC') dataBits = encodeNumeric(data);
            else if (mode === 'ALPHANUMERIC') dataBits = encodeAlphanumeric(data);
            else dataBits = encodeByte(data);
            bits.push(...dataBits);
            const eccInfo = ECC_TABLE[version][eccLevel];
            let totalDataCodewords = 0;
            for (const [count, dataWords] of eccInfo.blocks) {
                totalDataCodewords += count * dataWords;
            }
            const totalDataBits = totalDataCodewords * 8;
            const terminatorLength = Math.min(4, totalDataBits - bits.length);
            for (let i = 0; i < terminatorLength; i++) bits.push(0);
            while (bits.length % 8 !== 0) bits.push(0);
            const padCodewords = [0xEC, 0x11];
            let padIndex = 0;
            while (bits.length < totalDataBits) {
                const pad = padCodewords[padIndex % 2];
                for (let i = 7; i >= 0; i--) bits.push((pad >> i) & 1);
                padIndex++;
            }
            return bits;
        }

        function bitsToCodewords(bits) {
            const codewords = [];
            for (let i = 0; i < bits.length; i += 8) {
                let value = 0;
                for (let j = 0; j < 8; j++) value = (value << 1) | bits[i + j];
                codewords.push(value);
            }
            return codewords;
        }

        function generateErrorCorrection(dataCodewords, version, eccLevel) {
            const eccInfo = ECC_TABLE[version][eccLevel];
            const blocks = [];
            let dataIndex = 0;
            for (const [count, dataWords] of eccInfo.blocks) {
                for (let i = 0; i < count; i++) {
                    const blockData = dataCodewords.slice(dataIndex, dataIndex + dataWords);
                    const ecc = calculateECC(blockData, eccInfo.eccPerBlock);
                    blocks.push({ data: Array.from(blockData), ecc: Array.from(ecc) });
                    dataIndex += dataWords;
                }
            }
            const result = [];
            const maxDataLength = Math.max(...blocks.map(b => b.data.length));
            for (let i = 0; i < maxDataLength; i++) {
                for (const block of blocks) {
                    if (i < block.data.length) result.push(block.data[i]);
                }
            }
            for (let i = 0; i < eccInfo.eccPerBlock; i++) {
                for (const block of blocks) result.push(block.ecc[i]);
            }
            return result;
        }

        function createMatrix(version) {
            const size = version * 4 + 17;
            const matrix = [];
            const reserved = [];
            for (let i = 0; i < size; i++) {
                matrix[i] = new Array(size).fill(null);
                reserved[i] = new Array(size).fill(false);
            }
            return { matrix, reserved, size };
        }

        function placeFinderPattern(matrix, reserved, row, col) {
            for (let r = -1; r <= 7; r++) {
                for (let c = -1; c <= 7; c++) {
                    const mr = row + r;
                    const mc = col + c;
                    if (mr < 0 || mr >= matrix.length || mc < 0 || mc >= matrix.length) continue;
                    if (r === -1 || r === 7 || c === -1 || c === 7) matrix[mr][mc] = 0;
                    else if (r === 0 || r === 6 || c === 0 || c === 6) matrix[mr][mc] = 1;
                    else if (r >= 2 && r <= 4 && c >= 2 && c <= 4) matrix[mr][mc] = 1;
                    else matrix[mr][mc] = 0;
                    reserved[mr][mc] = true;
                }
            }
        }

        function placeAlignmentPattern(matrix, reserved, centerRow, centerCol) {
            for (let r = -2; r <= 2; r++) {
                for (let c = -2; c <= 2; c++) {
                    const mr = centerRow + r;
                    const mc = centerCol + c;
                    if (reserved[mr][mc]) continue;
                    if (r === -2 || r === 2 || c === -2 || c === 2) matrix[mr][mc] = 1;
                    else if (r === 0 && c === 0) matrix[mr][mc] = 1;
                    else matrix[mr][mc] = 0;
                    reserved[mr][mc] = true;
                }
            }
        }

        function placeTimingPatterns(matrix, reserved, size) {
            for (let i = 8; i < size - 8; i++) {
                const bit = (i + 1) % 2;
                if (!reserved[6][i]) { matrix[6][i] = bit; reserved[6][i] = true; }
                if (!reserved[i][6]) { matrix[i][6] = bit; reserved[i][6] = true; }
            }
        }

        function placeDarkModule(matrix, reserved, version) {
            // Dark module at position (4*version + 9, 8) per ISO 18004
            // That's row = 4V+9, column = 8
            const row = 4 * version + 9;
            matrix[row][8] = 1;
            reserved[row][8] = true;
        }

        function reserveFormatInfo(matrix, reserved, size) {
            for (let i = 0; i < 9; i++) {
                if (!reserved[8][i]) reserved[8][i] = true;
                if (!reserved[i][8]) reserved[i][8] = true;
            }
            for (let i = 0; i < 8; i++) {
                if (!reserved[size - 1 - i][8]) reserved[size - 1 - i][8] = true;
            }
            for (let i = 0; i < 8; i++) {
                if (!reserved[8][size - 1 - i]) reserved[8][size - 1 - i] = true;
            }
        }

        function reserveVersionInfo(matrix, reserved, size, version) {
            if (version < 7) return;
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 3; j++) {
                    reserved[size - 11 + j][i] = true;
                }
            }
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 3; j++) {
                    reserved[i][size - 11 + j] = true;
                }
            }
        }

        function placeDataModules(matrix, reserved, size, data) {
            let dataIndex = 0;
            let upward = true;
            for (let col = size - 1; col > 0; col -= 2) {
                if (col === 6) col = 5;
                for (let row = 0; row < size; row++) {
                    const actualRow = upward ? size - 1 - row : row;
                    if (!reserved[actualRow][col] && dataIndex < data.length) {
                        matrix[actualRow][col] = data[dataIndex++];
                    }
                    if (col > 0 && !reserved[actualRow][col - 1] && dataIndex < data.length) {
                        matrix[actualRow][col - 1] = data[dataIndex++];
                    }
                }
                upward = !upward;
            }
        }

        function buildFunctionPatterns(version) {
            const { matrix, reserved, size } = createMatrix(version);
            placeFinderPattern(matrix, reserved, 0, 0);
            placeFinderPattern(matrix, reserved, 0, size - 7);
            placeFinderPattern(matrix, reserved, size - 7, 0);
            if (version >= 2) {
                const positions = ALIGNMENT_PATTERNS[version];
                for (let i = 0; i < positions.length; i++) {
                    for (let j = 0; j < positions.length; j++) {
                        const row = positions[i];
                        const col = positions[j];
                        if ((row < 9 && col < 9) || (row < 9 && col > size - 10) || (row > size - 10 && col < 9)) continue;
                        placeAlignmentPattern(matrix, reserved, row, col);
                    }
                }
            }
            placeTimingPatterns(matrix, reserved, size);
            placeDarkModule(matrix, reserved, version);
            reserveFormatInfo(matrix, reserved, size);
            reserveVersionInfo(matrix, reserved, size, version);
            return { matrix, reserved, size };
        }

        const MASK_PATTERNS = [
            (i, j) => (i + j) % 2 === 0,
            (i, j) => i % 2 === 0,
            (i, j) => j % 3 === 0,
            (i, j) => (i + j) % 3 === 0,
            (i, j) => (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0,
            (i, j) => ((i * j) % 2) + ((i * j) % 3) === 0,
            (i, j) => (((i * j) % 2) + ((i * j) % 3)) % 2 === 0,
            (i, j) => (((i + j) % 2) + ((i * j) % 3)) % 2 === 0
        ];

        function applyMask(matrix, reserved, size, maskPattern) {
            const masked = matrix.map(row => [...row]);
            const condition = MASK_PATTERNS[maskPattern];
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (!reserved[i][j] && condition(i, j)) masked[i][j] ^= 1;
                }
            }
            return masked;
        }

        function evaluateMask(matrix, size) {
            let penalty = 0;
            for (let i = 0; i < size; i++) {
                let rowRun = 1, colRun = 1;
                for (let j = 1; j < size; j++) {
                    if (matrix[i][j] === matrix[i][j - 1]) rowRun++;
                    else { if (rowRun >= 5) penalty += 3 + (rowRun - 5); rowRun = 1; }
                    if (matrix[j][i] === matrix[j - 1][i]) colRun++;
                    else { if (colRun >= 5) penalty += 3 + (colRun - 5); colRun = 1; }
                }
                if (rowRun >= 5) penalty += 3 + (rowRun - 5);
                if (colRun >= 5) penalty += 3 + (colRun - 5);
            }
            for (let i = 0; i < size - 1; i++) {
                for (let j = 0; j < size - 1; j++) {
                    const color = matrix[i][j];
                    if (matrix[i][j + 1] === color && matrix[i + 1][j] === color && matrix[i + 1][j + 1] === color) penalty += 3;
                }
            }
            const pattern1 = [1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0];
            const pattern2 = [0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1];
            for (let i = 0; i < size; i++) {
                for (let j = 0; j <= size - 11; j++) {
                    let match1 = true, match2 = true;
                    for (let k = 0; k < 11; k++) {
                        if (matrix[i][j + k] !== pattern1[k]) match1 = false;
                        if (matrix[i][j + k] !== pattern2[k]) match2 = false;
                    }
                    if (match1 || match2) penalty += 40;
                    match1 = true; match2 = true;
                    for (let k = 0; k < 11; k++) {
                        if (matrix[j + k][i] !== pattern1[k]) match1 = false;
                        if (matrix[j + k][i] !== pattern2[k]) match2 = false;
                    }
                    if (match1 || match2) penalty += 40;
                }
            }
            let darkCount = 0;
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (matrix[i][j] === 1) darkCount++;
                }
            }
            const percent = (darkCount * 100) / (size * size);
            const deviation = Math.abs(percent - 50);
            penalty += Math.floor(deviation / 5) * 10;
            return penalty;
        }

        function selectBestMask(matrix, reserved, size) {
            let bestMask = 0;
            let bestPenalty = Infinity;
            for (let mask = 0; mask < 8; mask++) {
                const masked = applyMask(matrix, reserved, size, mask);
                const penalty = evaluateMask(masked, size);
                if (penalty < bestPenalty) { bestPenalty = penalty; bestMask = mask; }
            }
            return bestMask;
        }

        function placeFormatInfo(matrix, size, eccLevel, maskPattern) {
            const eccIndicator = ECC_INDICATORS[eccLevel];
            const formatData = (eccIndicator << 3) | maskPattern;
            const formatBits = FORMAT_INFO[formatData];
            // First copy around top-left finder (MSB first per ISO 18004)
            // Horizontal strip: row 8, columns 0-5 get bits 14-9
            for (let i = 0; i < 6; i++) matrix[8][i] = (formatBits >> (14 - i)) & 1;
            matrix[8][7] = (formatBits >> 8) & 1;
            matrix[8][8] = (formatBits >> 7) & 1;
            // Vertical strip: row 7 gets bit 6, rows 5-0 get bits 5-0
            matrix[7][8] = (formatBits >> 6) & 1;
            for (let i = 0; i < 6; i++) matrix[5 - i][8] = (formatBits >> (5 - i)) & 1;
            // Second copy: bottom-left (bits 0-6) and top-right (bits 7-14)
            // Per ISO 18004: D0 at row n-1, D1 at row n-2, ... D6 at row n-7
            for (let i = 0; i < 7; i++) matrix[size - 1 - i][8] = (formatBits >> i) & 1;
            for (let i = 0; i < 8; i++) matrix[8][size - 8 + i] = (formatBits >> (7 + i)) & 1;
        }

        function placeVersionInfo(matrix, size, version) {
            if (version < 7) return;
            const versionBits = VERSION_INFO[version];
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 3; j++) {
                    const bit = (versionBits >> (i * 3 + j)) & 1;
                    matrix[size - 11 + j][i] = bit;
                }
            }
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 3; j++) {
                    const bit = (versionBits >> (i * 3 + j)) & 1;
                    matrix[i][size - 11 + j] = bit;
                }
            }
        }

        function generate(data, eccLevel = 'M') {
            if (!data || data.length === 0) throw new Error('Data cannot be empty');
            const mode = detectMode(data);
            let dataLength;
            if (mode === 'BYTE') {
                const encoder = new TextEncoder();
                dataLength = encoder.encode(data).length;
            } else {
                dataLength = data.length;
            }
            const version = selectVersion(dataLength, eccLevel, mode);
            if (version === -1) throw new Error('Data too long for QR code');
            const dataBits = createDataBitstream(data, version, eccLevel, mode);
            const dataCodewords = bitsToCodewords(dataBits);
            const finalCodewords = generateErrorCorrection(dataCodewords, version, eccLevel);
            const bits = [];
            for (const codeword of finalCodewords) {
                for (let i = 7; i >= 0; i--) bits.push((codeword >> i) & 1);
            }
            const remainderCount = REMAINDER_BITS[version];
            for (let i = 0; i < remainderCount; i++) bits.push(0);
            const { matrix, reserved, size } = buildFunctionPatterns(version);
            placeDataModules(matrix, reserved, size, bits);
            const maskPattern = selectBestMask(matrix, reserved, size);
            const maskedMatrix = applyMask(matrix, reserved, size, maskPattern);
            placeFormatInfo(maskedMatrix, size, eccLevel, maskPattern);
            placeVersionInfo(maskedMatrix, size, version);
            return { matrix: maskedMatrix, version, size, eccLevel, maskPattern, mode, dataLength };
        }

        function render(canvas, qrData, moduleSize = 8) {
            const { matrix, size } = qrData;
            const quietZone = 4;
            const totalSize = (size + quietZone * 2) * moduleSize;
            canvas.width = totalSize;
            canvas.height = totalSize;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, totalSize, totalSize);
            ctx.fillStyle = '#000000';
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (matrix[i][j] === 1) {
                        ctx.fillRect((j + quietZone) * moduleSize, (i + quietZone) * moduleSize, moduleSize, moduleSize);
                    }
                }
            }
        }

        return {
            generate,
            render,
            _internal: {
                detectMode,
                encodeNumeric,
                encodeAlphanumeric,
                encodeByte,
                calculateECC,
                evaluateMask,
                MASK_PATTERNS,
                BYTE_CAPACITY,
                ECC_TABLE,
                FORMAT_INFO,
                VERSION_INFO,
                ALIGNMENT_PATTERNS
            }
        };
    })();

    // ============================================================
    // TEST FRAMEWORK
    // ============================================================

    const TestRunner = (function() {
        'use strict';

        const results = [];
        const sections = {};

        function assert(condition, message) {
            if (!condition) {
                throw new Error(message || 'Assertion failed');
            }
        }

        function assertEqual(actual, expected, message) {
            if (actual !== expected) {
                throw new Error(`${message || 'Assertion failed'}: expected ${expected}, got ${actual}`);
            }
        }

        function assertArrayEqual(actual, expected, message) {
            if (actual.length !== expected.length) {
                throw new Error(`${message || 'Array length mismatch'}: expected ${expected.length}, got ${actual.length}`);
            }
            for (let i = 0; i < actual.length; i++) {
                if (actual[i] !== expected[i]) {
                    throw new Error(`${message || 'Array mismatch'} at index ${i}: expected ${expected[i]}, got ${actual[i]}`);
                }
            }
        }

        function test(name, section, fn) {
            const start = performance.now();
            let passed = true;
            let error = null;

            try {
                fn();
            } catch (e) {
                passed = false;
                error = e.message;
            }

            const end = performance.now();
            const result = {
                name,
                section,
                passed,
                error,
                time: end - start
            };

            results.push(result);

            if (!sections[section]) {
                sections[section] = [];
            }
            sections[section].push(result);

            return result;
        }

        function getResults() {
            return results;
        }

        function getSections() {
            return sections;
        }

        function getSummary() {
            const total = results.length;
            const passed = results.filter(r => r.passed).length;
            const failed = total - passed;
            return { total, passed, failed };
        }

        function clear() {
            results.length = 0;
            for (const key in sections) {
                delete sections[key];
            }
        }

        return {
            assert,
            assertEqual,
            assertArrayEqual,
            test,
            getResults,
            getSections,
            getSummary,
            clear
        };
    })();

    // ============================================================
    // TEST CASES
    // ============================================================

    function runAllTests() {
        TestRunner.clear();

        // ========================
        // MODE DETECTION TESTS
        // ========================

        TestRunner.test('Detect numeric mode for digits only', 'Mode Detection', () => {
            const mode = QRCode._internal.detectMode('0123456789');
            TestRunner.assertEqual(mode, 'NUMERIC');
        });

        TestRunner.test('Detect alphanumeric mode for uppercase letters', 'Mode Detection', () => {
            const mode = QRCode._internal.detectMode('HELLO WORLD');
            TestRunner.assertEqual(mode, 'ALPHANUMERIC');
        });

        TestRunner.test('Detect alphanumeric mode for mixed case with special chars', 'Mode Detection', () => {
            const mode = QRCode._internal.detectMode('HTTPS://EXAMPLE.COM');
            TestRunner.assertEqual(mode, 'ALPHANUMERIC');
        });

        TestRunner.test('Detect byte mode for lowercase letters', 'Mode Detection', () => {
            const mode = QRCode._internal.detectMode('https://example.com');
            TestRunner.assertEqual(mode, 'BYTE');
        });

        TestRunner.test('Detect byte mode for special characters', 'Mode Detection', () => {
            const mode = QRCode._internal.detectMode('hello@world.com');
            TestRunner.assertEqual(mode, 'BYTE');
        });

        // ========================
        // NUMERIC ENCODING TESTS
        // ========================

        TestRunner.test('Encode "01234567" as numeric (from ISO example)', 'Numeric Encoding', () => {
            const bits = QRCode._internal.encodeNumeric('01234567');
            // 012 -> 12 -> 0000001100 (10 bits)
            // 345 -> 345 -> 0101011001 (10 bits)
            // 67 -> 67 -> 1000011 (7 bits)
            TestRunner.assertEqual(bits.length, 27);
        });

        TestRunner.test('Encode single digit', 'Numeric Encoding', () => {
            const bits = QRCode._internal.encodeNumeric('7');
            // 7 -> 0111 (4 bits)
            TestRunner.assertEqual(bits.length, 4);
            TestRunner.assertArrayEqual(bits, [0, 1, 1, 1]);
        });

        TestRunner.test('Encode two digits', 'Numeric Encoding', () => {
            const bits = QRCode._internal.encodeNumeric('67');
            // 67 -> 1000011 (7 bits)
            TestRunner.assertEqual(bits.length, 7);
        });

        TestRunner.test('Encode three digits', 'Numeric Encoding', () => {
            const bits = QRCode._internal.encodeNumeric('123');
            // 123 -> 0001111011 (10 bits)
            TestRunner.assertEqual(bits.length, 10);
        });

        // ========================
        // ALPHANUMERIC ENCODING TESTS
        // ========================

        TestRunner.test('Encode "AC-42" as alphanumeric (from ISO example)', 'Alphanumeric Encoding', () => {
            const bits = QRCode._internal.encodeAlphanumeric('AC-42');
            // AC -> 10*45 + 12 = 462 -> 00111001110 (11 bits)
            // -4 -> 41*45 + 4 = 1849 -> 11100111001 (11 bits)
            // 2 -> 2 -> 000010 (6 bits)
            TestRunner.assertEqual(bits.length, 28);
        });

        TestRunner.test('Encode single alphanumeric character', 'Alphanumeric Encoding', () => {
            const bits = QRCode._internal.encodeAlphanumeric('A');
            // A = 10 -> 001010 (6 bits)
            TestRunner.assertEqual(bits.length, 6);
        });

        TestRunner.test('Encode pair of alphanumeric characters', 'Alphanumeric Encoding', () => {
            const bits = QRCode._internal.encodeAlphanumeric('AB');
            // AB -> 10*45 + 11 = 461 -> 00111001101 (11 bits)
            TestRunner.assertEqual(bits.length, 11);
        });

        // ========================
        // BYTE ENCODING TESTS
        // ========================

        TestRunner.test('Encode ASCII text as byte', 'Byte Encoding', () => {
            const bits = QRCode._internal.encodeByte('hello');
            // 5 bytes * 8 bits = 40 bits
            TestRunner.assertEqual(bits.length, 40);
        });

        TestRunner.test('Encode UTF-8 text with multibyte characters', 'Byte Encoding', () => {
            const bits = QRCode._internal.encodeByte('hello');
            // Verify first character 'h' = 0x68 = 01101000
            TestRunner.assertArrayEqual(bits.slice(0, 8), [0, 1, 1, 0, 1, 0, 0, 0]);
        });

        TestRunner.test('Encode URL with special characters', 'Byte Encoding', () => {
            const bits = QRCode._internal.encodeByte('https://example.com?q=test');
            TestRunner.assertEqual(bits.length, 26 * 8); // 26 characters
        });

        // ========================
        // ERROR CORRECTION TESTS
        // ========================

        TestRunner.test('Calculate ECC for simple data block', 'Error Correction', () => {
            // Test with known polynomial coefficients
            const data = new Uint8Array([32, 91, 11, 120, 209, 114, 220, 77]);
            const ecc = QRCode._internal.calculateECC(data, 10);
            TestRunner.assertEqual(ecc.length, 10);
        });

        TestRunner.test('ECC generates correct number of codewords', 'Error Correction', () => {
            const data = new Uint8Array([64, 196, 132, 84, 196, 196, 242, 194, 4, 132, 20, 37, 34, 16, 236, 17]);
            const ecc = QRCode._internal.calculateECC(data, 10);
            TestRunner.assertEqual(ecc.length, 10);
        });

        TestRunner.test('ECC values are in valid range (0-255)', 'Error Correction', () => {
            const data = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
            const ecc = QRCode._internal.calculateECC(data, 7);
            for (let i = 0; i < ecc.length; i++) {
                TestRunner.assert(ecc[i] >= 0 && ecc[i] <= 255, `ECC value ${ecc[i]} out of range`);
            }
        });

        // ========================
        // MASK PATTERN TESTS
        // ========================

        TestRunner.test('Mask pattern 0: (i + j) mod 2 = 0', 'Mask Patterns', () => {
            const pattern = QRCode._internal.MASK_PATTERNS[0];
            TestRunner.assertEqual(pattern(0, 0), true);  // 0+0 = 0, 0 mod 2 = 0
            TestRunner.assertEqual(pattern(0, 1), false); // 0+1 = 1, 1 mod 2 = 1
            TestRunner.assertEqual(pattern(1, 1), true);  // 1+1 = 2, 2 mod 2 = 0
        });

        TestRunner.test('Mask pattern 1: i mod 2 = 0', 'Mask Patterns', () => {
            const pattern = QRCode._internal.MASK_PATTERNS[1];
            TestRunner.assertEqual(pattern(0, 0), true);
            TestRunner.assertEqual(pattern(1, 0), false);
            TestRunner.assertEqual(pattern(2, 5), true);
        });

        TestRunner.test('Mask pattern 2: j mod 3 = 0', 'Mask Patterns', () => {
            const pattern = QRCode._internal.MASK_PATTERNS[2];
            TestRunner.assertEqual(pattern(5, 0), true);
            TestRunner.assertEqual(pattern(5, 1), false);
            TestRunner.assertEqual(pattern(5, 3), true);
        });

        TestRunner.test('Mask pattern evaluation returns positive score', 'Mask Patterns', () => {
            // Create a simple test matrix
            const size = 21;
            const matrix = [];
            for (let i = 0; i < size; i++) {
                matrix[i] = [];
                for (let j = 0; j < size; j++) {
                    matrix[i][j] = (i + j) % 2;
                }
            }
            const score = QRCode._internal.evaluateMask(matrix, size);
            TestRunner.assert(score >= 0, 'Score should be non-negative');
        });

        // ========================
        // FORMAT INFO TESTS
        // ========================

        TestRunner.test('Format info lookup returns valid values', 'Format Information', () => {
            // All format info values should be 15-bit
            for (let i = 0; i < 32; i++) {
                const value = QRCode._internal.FORMAT_INFO[i];
                TestRunner.assert(value >= 0 && value <= 0x7FFF, `Format info ${i} out of range`);
            }
        });

        TestRunner.test('Format info for L-0 is correct (0x77C4)', 'Format Information', () => {
            // ECC L = 01, mask 0 = 000, data = 01000 = 8
            const formatInfo = QRCode._internal.FORMAT_INFO[8];
            TestRunner.assertEqual(formatInfo, 0x77C4);
        });

        TestRunner.test('Format info for M-0 is correct (0x5412)', 'Format Information', () => {
            // ECC M = 00, mask 0 = 000, data = 00000 = 0
            const formatInfo = QRCode._internal.FORMAT_INFO[0];
            TestRunner.assertEqual(formatInfo, 0x5412);
        });

        // ========================
        // VERSION INFO TESTS
        // ========================

        TestRunner.test('Version info exists only for versions 7+', 'Version Information', () => {
            for (let v = 1; v <= 6; v++) {
                TestRunner.assertEqual(QRCode._internal.VERSION_INFO[v], null);
            }
            for (let v = 7; v <= 40; v++) {
                TestRunner.assert(QRCode._internal.VERSION_INFO[v] !== null, `Version ${v} info missing`);
            }
        });

        TestRunner.test('Version 7 info is correct (0x07C94)', 'Version Information', () => {
            TestRunner.assertEqual(QRCode._internal.VERSION_INFO[7], 0x07C94);
        });

        TestRunner.test('Version 40 info is correct (0x28C69)', 'Version Information', () => {
            TestRunner.assertEqual(QRCode._internal.VERSION_INFO[40], 0x28C69);
        });

        // ========================
        // ALIGNMENT PATTERN TESTS
        // ========================

        TestRunner.test('Version 1 has no alignment patterns', 'Alignment Patterns', () => {
            TestRunner.assertEqual(QRCode._internal.ALIGNMENT_PATTERNS[1].length, 0);
        });

        TestRunner.test('Version 2 has alignment pattern at [6, 18]', 'Alignment Patterns', () => {
            TestRunner.assertArrayEqual(QRCode._internal.ALIGNMENT_PATTERNS[2], [6, 18]);
        });

        TestRunner.test('Version 7 has 3 alignment pattern coordinates', 'Alignment Patterns', () => {
            TestRunner.assertEqual(QRCode._internal.ALIGNMENT_PATTERNS[7].length, 3);
            TestRunner.assertArrayEqual(QRCode._internal.ALIGNMENT_PATTERNS[7], [6, 22, 38]);
        });

        // ========================
        // INTEGRATION TESTS
        // ========================

        TestRunner.test('Generate QR code for simple URL', 'Integration', () => {
            const qr = QRCode.generate('https://example.com', 'M');
            TestRunner.assert(qr.matrix !== null, 'Matrix should not be null');
            TestRunner.assert(qr.version >= 1 && qr.version <= 40, 'Version should be 1-40');
            TestRunner.assertEqual(qr.size, qr.version * 4 + 17);
        });

        TestRunner.test('Version 1 generates 21x21 matrix', 'Integration', () => {
            const qr = QRCode.generate('A', 'L');
            TestRunner.assertEqual(qr.version, 1);
            TestRunner.assertEqual(qr.size, 21);
            TestRunner.assertEqual(qr.matrix.length, 21);
            TestRunner.assertEqual(qr.matrix[0].length, 21);
        });

        TestRunner.test('Error correction level is preserved', 'Integration', () => {
            ['L', 'M', 'Q', 'H'].forEach(level => {
                const qr = QRCode.generate('TEST', level);
                TestRunner.assertEqual(qr.eccLevel, level);
            });
        });

        TestRunner.test('Mode is correctly detected and stored', 'Integration', () => {
            const numericQR = QRCode.generate('12345', 'M');
            TestRunner.assertEqual(numericQR.mode, 'NUMERIC');

            const alphaQR = QRCode.generate('HELLO', 'M');
            TestRunner.assertEqual(alphaQR.mode, 'ALPHANUMERIC');

            const byteQR = QRCode.generate('hello', 'M');
            TestRunner.assertEqual(byteQR.mode, 'BYTE');
        });

        TestRunner.test('Mask pattern is valid (0-7)', 'Integration', () => {
            const qr = QRCode.generate('https://example.com', 'M');
            TestRunner.assert(qr.maskPattern >= 0 && qr.maskPattern <= 7);
        });

        TestRunner.test('Matrix contains only 0 and 1 values', 'Integration', () => {
            const qr = QRCode.generate('https://example.com', 'M');
            for (let i = 0; i < qr.size; i++) {
                for (let j = 0; j < qr.size; j++) {
                    TestRunner.assert(qr.matrix[i][j] === 0 || qr.matrix[i][j] === 1,
                        `Invalid value at (${i}, ${j}): ${qr.matrix[i][j]}`);
                }
            }
        });

        TestRunner.test('Finder patterns are correctly placed', 'Integration', () => {
            const qr = QRCode.generate('TEST', 'M');
            const size = qr.size;

            // Check top-left finder pattern center (3,3) is dark
            TestRunner.assertEqual(qr.matrix[3][3], 1, 'Top-left finder center should be dark');

            // Check top-right finder pattern center (3, size-4) is dark
            TestRunner.assertEqual(qr.matrix[3][size - 4], 1, 'Top-right finder center should be dark');

            // Check bottom-left finder pattern center (size-4, 3) is dark
            TestRunner.assertEqual(qr.matrix[size - 4][3], 1, 'Bottom-left finder center should be dark');
        });

        // ========================
        // EDGE CASE TESTS
        // ========================

        TestRunner.test('Empty input throws error', 'Edge Cases', () => {
            let threw = false;
            try {
                QRCode.generate('', 'M');
            } catch (e) {
                threw = true;
            }
            TestRunner.assert(threw, 'Should throw error for empty input');
        });

        TestRunner.test('Single character input works', 'Edge Cases', () => {
            const qr = QRCode.generate('A', 'L');
            TestRunner.assert(qr !== null);
        });

        TestRunner.test('Maximum capacity URL for version 1-L', 'Edge Cases', () => {
            // Version 1-L can hold 17 bytes
            const url = 'http://x.co/12345'; // 17 chars
            const qr = QRCode.generate(url, 'L');
            TestRunner.assertEqual(qr.version, 1);
        });

        TestRunner.test('URL longer than version 1 capacity uses version 2+', 'Edge Cases', () => {
            // More than 17 bytes should require version 2+
            const url = 'https://example.com/test';
            const qr = QRCode.generate(url, 'L');
            TestRunner.assert(qr.version >= 2);
        });

        TestRunner.test('Special URL characters are handled', 'Edge Cases', () => {
            const url = 'https://example.com/path?query=value&foo=bar#anchor';
            const qr = QRCode.generate(url, 'M');
            TestRunner.assert(qr !== null);
        });

        TestRunner.test('Unicode URL is handled', 'Edge Cases', () => {
            const url = 'https://example.com/path';
            const qr = QRCode.generate(url, 'M');
            TestRunner.assert(qr !== null);
        });

        TestRunner.test('Very long URL uses higher version', 'Edge Cases', () => {
            // 250 bytes requires version 10-L (capacity 271 bytes), not version 9-L (capacity 230 bytes)
            const url = 'https://example.com/' + 'a'.repeat(230);
            const qr = QRCode.generate(url, 'L');
            TestRunner.assert(qr.version >= 10, `Expected version >= 10, got ${qr.version}`);
        });

        // ========================
        // VERSION SELECTION TESTS
        // ========================

        TestRunner.test('Correct version for different ECC levels', 'Version Selection', () => {
            const url = 'https://example.com';

            const qrL = QRCode.generate(url, 'L');
            const qrH = QRCode.generate(url, 'H');

            // Higher ECC should require same or higher version
            TestRunner.assert(qrH.version >= qrL.version);
        });

        TestRunner.test('Version selection matches capacity table', 'Version Selection', () => {
            // Version 1-M can hold 14 bytes
            const capacity = QRCode._internal.BYTE_CAPACITY[1][1]; // [version][M=1]
            TestRunner.assertEqual(capacity, 14);

            // Verify a 14-byte string fits in version 1-M
            const url = 'http://x.co/ab'; // 14 chars
            const qr = QRCode.generate(url, 'M');
            TestRunner.assertEqual(qr.version, 1);
        });

        // ========================
        // RENDERING TESTS
        // ========================

        TestRunner.test('Render creates canvas with correct dimensions', 'Rendering', () => {
            const canvas = document.createElement('canvas');
            const qr = QRCode.generate('TEST', 'M');
            const moduleSize = 8;
            const quietZone = 4;

            QRCode.render(canvas, qr, moduleSize);

            const expectedSize = (qr.size + quietZone * 2) * moduleSize;
            TestRunner.assertEqual(canvas.width, expectedSize);
            TestRunner.assertEqual(canvas.height, expectedSize);
        });

        TestRunner.test('Render with different module sizes', 'Rendering', () => {
            [4, 6, 8, 10, 12].forEach(moduleSize => {
                const canvas = document.createElement('canvas');
                const qr = QRCode.generate('TEST', 'M');

                QRCode.render(canvas, qr, moduleSize);

                const quietZone = 4;
                const expectedSize = (qr.size + quietZone * 2) * moduleSize;
                TestRunner.assertEqual(canvas.width, expectedSize);
            });
        });
    }

    // ============================================================
    // UI RENDERING
    // ============================================================

    function renderResults() {
        const summary = TestRunner.getSummary();
        document.getElementById('totalCount').textContent = summary.total;
        document.getElementById('passedCount').textContent = summary.passed;
        document.getElementById('failedCount').textContent = summary.failed;

        const sections = TestRunner.getSections();
        const container = document.getElementById('testResults');
        container.innerHTML = '';

        for (const [sectionName, tests] of Object.entries(sections)) {
            const passed = tests.filter(t => t.passed).length;
            const total = tests.length;

            const section = document.createElement('div');
            section.className = 'test-section';
            section.innerHTML = `
                <div class="section-header">
                    <span>${sectionName}</span>
                    <span class="badge">${passed}/${total} passed</span>
                </div>
                <div class="test-list">
                    ${tests.map(test => `
                        <div class="test-item">
                            <div class="test-icon ${test.passed ? 'pass' : 'fail'}">
                                ${test.passed ? '&#10003;' : '&#10007;'}
                            </div>
                            <div class="test-name">${test.name}</div>
                            <div class="test-details">${test.error || ''}</div>
                            <div class="test-time">${test.time.toFixed(2)}ms</div>
                        </div>
                    `).join('')}
                </div>
            `;
            container.appendChild(section);
        }
    }

    function renderVisualTests() {
        const container = document.getElementById('visualTestContainer');
        container.innerHTML = '';

        const testCases = [
            { url: 'https://example.com', ecc: 'L', label: 'Simple URL (ECC-L)' },
            { url: 'https://example.com', ecc: 'M', label: 'Simple URL (ECC-M)' },
            { url: 'https://example.com', ecc: 'Q', label: 'Simple URL (ECC-Q)' },
            { url: 'https://example.com', ecc: 'H', label: 'Simple URL (ECC-H)' },
            { url: 'https://github.com/user/repo', ecc: 'M', label: 'GitHub URL' },
            { url: 'https://example.com/path?query=value&foo=bar', ecc: 'M', label: 'URL with Query Params' },
            { url: '12345', ecc: 'M', label: 'Numeric Only' },
            { url: 'HELLO WORLD', ecc: 'M', label: 'Alphanumeric Only' }
        ];

        testCases.forEach(testCase => {
            try {
                const qr = QRCode.generate(testCase.url, testCase.ecc);

                const div = document.createElement('div');
                div.className = 'visual-test';

                const canvas = document.createElement('canvas');
                QRCode.render(canvas, qr, 4);

                div.innerHTML = `<h4>${testCase.label}</h4>`;
                div.appendChild(canvas);
                div.innerHTML += `
                    <div class="meta">
                        Version ${qr.version} | ${qr.size}x${qr.size} | Mask ${qr.maskPattern}<br>
                        <small>${testCase.url}</small>
                    </div>
                `;

                container.appendChild(div);
            } catch (e) {
                console.error(`Failed to generate QR for ${testCase.label}:`, e);
            }
        });

        document.getElementById('visualBadge').textContent = `${testCases.length} codes`;
    }

    // ============================================================
    // INITIALIZATION
    // ============================================================

    document.getElementById('runTests').addEventListener('click', () => {
        runAllTests();
        renderResults();
        renderVisualTests();
    });

    // Auto-run tests on load
    window.addEventListener('load', () => {
        runAllTests();
        renderResults();
        renderVisualTests();
    });
    </script>
</body>
</html>
